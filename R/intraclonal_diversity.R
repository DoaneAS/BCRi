


#' Takes a db, a cloneID, and the name of a phenotype variable and returns the affinity matrix, db, and data.frame of per-phenotype diversity metrics for that clone
#'
#' @param db
#' @param cloneID
#' @param phenotype_var
#' @param cell_id
#' @param clone
#'
#' @returns list with affinity matrix, db for clone, and data.frame of per-phenotype diversity metrics
#' @export
#'
#' @examples
intraclonal_diversities <- function(db, cloneID, phenotype_var="subset", cell_id=NULL, clone = "clone_id") {
  require(igraph)
  model = "spectral"
  method = "vj"
  linkage = c("single", "average", "complete")
  normalize = "len" ## c("len", "none"),
  germline = "germline_alignment_d_mask"
  sequence = "sequence_alignment"
  junction = "junction"
  v_call = "v_call_genotyped"
  j_call = "j_call"
  fields = NULL
  locus = "locus"
  only_heavy = TRUE
  split_light = FALSE
  targeting_model = HH_S5F
  len_limit = NULL
  first = FALSE
  cdr3 = FALSE
  mod3 = FALSE
  max_n = 0
  threshold = 1
  base_sim = 0.95
  iter_max = 1000
  nstart = 1000
  nproc = 4
  verbose = FALSE
  log = NULL
  summarize_clones = FALSE

  # get clone

  db_clone <- as.data.frame(db[db$clone_id == cloneID, ])
  results_prep = prepare_clone(db = db_clone,
                               junction = junction, v_call = v_call, j_call = j_call,
                               first = first, cdr3 = cdr3, fields = fields,
                               cell_id = cell_id, locus = locus, only_heavy = only_heavy,
                               mod3 = mod3, max_n = max_n)
  dbfull = data.table::copy(db)
  db <- results_prep$db
  n_rmv_mod3 <- results_prep$n_rmv_mod3
  n_rmv_cdr3 <- results_prep$n_rmv_cdr3
  n_rmv_N <- results_prep$n_rmv_N
  junction_l <- results_prep$junction_l
  cdr3_col <-  results_prep$cdr3_col

  db_l <- db[db[[locus]] %in% c("IGK", "IGL", "TRA", "TRG"), , drop=F]
  db <- db[db[[locus]] %in% c("IGH", "TRB", "TRD"), , drop=F]
  db_gp <- db
  #groupBy <- c("vjl_group")

  ### summary of the groups
  # vjl_gps <- db %>%
  #   dplyr::group_by(!!!rlang::syms(groupBy)) %>%
  #   dplyr::summarise(group_v_call = stringi::stri_join(unique(!!rlang::sym(v_call)), collapse=","),
  #                    group_j_call = stringi::stri_join(unique(!!rlang::sym(j_call)), collapse=","),
  #                    group_junction_length = unique(!!rlang::sym(junction_l)),
  #                    group_size = n())
  # vjl_gps$group_v_call <- sapply(1:nrow(vjl_gps),
  #                                function(i){ stringi::stri_join(unique(stringi::stri_split_fixed(vjl_gps$group_v_call[i], ",")[[1]]), collapse=",") })
  # vjl_gps$group_j_call <- sapply(1:nrow(vjl_gps),
  #                                function(i){ stringi::stri_join(unique(stringi::stri_split_fixed(vjl_gps$group_j_call[i], ",")[[1]]), collapse=",") })
  # n_groups <- nrow(vjl_gps)

  ## a single clone will have only 1 vjl group
  # gp <- vjl_gps$vjl_group[1]
  #
  # len_limit = NULL
  # vjl_gp <- vjl_gps$vjl_group[gp]
  # gp_vcall <- vjl_gps$group_v_call[gp]
  # gp_jcall <- vjl_gps$group_j_call[gp]
  # gp_lent <- vjl_gps$group_junction_length[gp]
  # gp_size <- vjl_gps$group_size[gp]
  # db_gp <- dplyr::filter(db, !!rlang::sym("vjl_group") == vjl_gp)
  #
  mutabs <- shazam::HH_S5F@mutability
  # Generated by using Rcpp::compileAttributes() -> do not edit by hand
  # Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

  Rcpp::sourceCpp("./src/RcppMutation.cpp")

  n <- nrow(db_gp)

  ### cloning
  # if (method == "vj") {
  #   ### check targeting model
  #   if (!is.null(mutabs)) {
  #     mutabs <- mutabs@mutability
  #   } else {
  #     mutabs <- NULL
  #   }
  # get required info based on the method
  germs <- db_gp[[germline]]
  seqs <- db_gp[[sequence]]
  juncs <- db_gp[[ifelse(cdr3, cdr3_col, junction)]]
  junc_length <- unique(stringi::stri_length(juncs))
  # find unique seqs
  seqs <- paste(seqs, juncs, germs, sep = "|")
  df <- data.table::as.data.table(seqs)[, list(list(.I)), by=seqs] %>%
    tidyr::separate(col = seqs, into = c("seqs_unq", "juncs_unq", "germs_unq"), sep = "\\|")
  n_unq <- nrow(df)
  ind_unq <- df$V1
  if (n_unq == 1) {
    db_gp$ind <- 0
    db_gp$Hi = 0
    db_gp$vertex_diversity = 0
    db_gp$gll = 0

    ind = "ind"

    dgc = db_gp %>% dplyr::group_by({{ ind }}, {{ phenotype_var }}) %>%
      dplyr::summarise(n = n())

    return_list = list("affinity_mat" = NULL,
                       "db_clone" = db_gp,
                       "g" = NULL,
                       "db_pheno"= dgc)

    return(return_list)
  }
  # find corresponding unique germs and junctions
  seqs_unq <- df$seqs_unq
  germs_unq <- df$germs_unq
  juncs_unq <- df$juncs_unq
  # calculate unique junctions distance matrix
  dist_mtx <- pairwiseDist(seq = juncs_unq,
                           dist_mat = getDNAMatrix(gap = 0))
  # count mutations from unique sequence imgt
  results <- pairwiseMutions(germ_imgt = germs_unq,
                             seq_imgt = seqs_unq,
                             junc_length = junc_length,
                             len_limit = len_limit,
                             cdr3 = cdr3,
                             mutabs = mutabs)
  tot_mtx <- results$pairWiseTotalMut
  sh_mtx <- results$pairWiseSharedMut
  mutab_mtx <- results$pairWiseMutability
  # calculate likelihhod matrix
  lkl_mtx <- likelihoods(tot_mtx = tot_mtx,
                         sh_mtx = sh_mtx,
                         mutab_mtx = mutab_mtx)
  # calculate weighted matrix
  disim_mtx <- dist_mtx * (1.0 - lkl_mtx)
  mtx = disim_mtx
  threshold = NULL
  base_sim = 0.95
  iter_max = 1000
  nstart = 1000
  mtx = disim_mtx
  #{
  ### constants
  n <- nrow(mtx)
  bs <- (1 - base_sim)*junc_length
  off_diags_nuq <- unique(mtx[row(mtx) != col(mtx)])

  krnl_mtx <- krnlMtxGenerator(mtx = mtx)
  aff_mtx <- krnl_mtx

  ## return clone db with unique seq identifier
  db_gp$ind <- 0

  for (i in 1:n_unq) {
    #idCluster[ind_unq[[i]]] <- idCluster_unq[i]
    db_gp$ind[ind_unq[[i]]] <- i
  }


  g = igraph::graph_from_adjacency_matrix(aff_mtx, mode = "undirected", weighted = TRUE)
  g =  igraph::simplify(g, remove.loops = TRUE, remove.multiple = FALSE)
  V(g)$k = igraph::degree(g)

  #v = igraph::eigen_centrality(g)$vector
  #db_gp$ev = v[ db_gp$ind]

  cent.div <- igraph::diversity(g)


  V(g)$Di <-  igraph::diversity(g)
  V(g)$Hi =  V(g)$Di * log10(V(g)$k)
  db_gp$Di = V(g)$Di[ db_gp$ind]
  db_gp$Hi = V(g)$Hi[ db_gp$ind]

  # for (i in 1:length(g)) {
  #   #spij = sum(E(g)[.from(i)]$weight / log(V(g)$k[i]))
  #   #spij = sum(g[i,] / log(V(g)$k[i]))
  #   V(g)$sumPij[i] = sum( g[i,] / log(V(g)$k[i]))
  #   #set_vertex_attr(g, index = V(g)[i], name = "sumPij", value = spij)
  #   #V(g)$sumPij[i] =  sum(g[i,] / log(V(g)$k[i]))
  # }


  #gll = list()
  for (i in 1:length(g)) {
    ## proportional weight
    pij = g[i,] / sum(g[i,])
    pij = pij[pij > 0]
    Hiw = (-1 * sum(pij * log10(pij)))
    Diw = Hiw / log10(V(g)$k[i])
    V(g)$Diw[i] = Diw
    V(g)$Hiw[i] = Hiw
    V(g)$sumw[i] = sum(pij * log10(pij))

    #pijg = g[i,] / sum(g[])
    # V(g)$pijg[i] = sum(pijg)

    ### different norms for edge weights
    # pijk = g[i,] / V(g)$k[i]
    # pijk = pijk[pijk > 0]
    # Hik = -1 * sum(pijk * log(pijk))
    # Dik = Hik / log10(V(g)$k[i])
    # V(g)$sumPijk[i] = sum(pijk)
    #
    # V(g)$Hik[i] = Hik
    # V(g)$Dik[i] = Dik
    #
    #
    # piju = g[i,]
    # piju = piju[piju > 0]
    #
    # Hiu = -1 * sum(piju * log(piju))
    # Diu = Hiu / log10(V(g)$k[i])
    # V(g)$sumPiju[i] = sum(piju)
    #
    # V(g)$Hiu[i] = Hiu
    # V(g)$Diu[i] = Diu

    #gll[i] = sum(pij) * log(sum(pij))
  }


  #db_gp$sumPij = V(g)$sumPij[ db_gp$ind]
  db_gp$Diw = V(g)$Diw[ db_gp$ind]
  db_gp$Hiw = V(g)$Hiw[ db_gp$ind]
  #db_gp$Dik = V(g)$Dik[ db_gp$ind]
  #db_gp$Hik = V(g)$Hik[ db_gp$ind]
  #db_gp$sumPijk = V(g)$sumPijk[ db_gp$ind]
  #db_gp$sumw = V(g)$sumw[ db_gp$ind]
  #db_gp$pijg = V(g)$pijg[ db_gp$ind]

  #db_gp$Diu = V(g)$Diu[ db_gp$ind]
  #db_gp$Hiu = V(g)$Hiu[ db_gp$ind]
  #db_gp$sumPiju = V(g)$sumPiju[ db_gp$ind]
  db_gp$n_clone = n_unq
  ind = "ind"
  #  grps = c(ind, phenotype_var)
  #dgc = db_gp %>% dplyr::group_by({{phenotype_var}}) %>%
  #  dplyr::summarise(n = n())
  #dgc$intra_clonotypic = 0

  dgc = data.frame(pheno = unique(db_gp[[phenotype_var]]))
  #dgc[[phenotype_var]] = unique(db_gp[[phenotype_var]])
  dgc$intra_clonotypic = 0
  dgc$inter_clonotypic_norm = 0
  dgc$sumPij = 0
  ## now get joint phenotype - entropy
  for (f in unique(db_gp[[phenotype_var]])) {
    fnodes = db_gp[db_gp[[phenotype_var]] == f,]
    fnodesindex = unique(fnodes$ind)

    pij = g[fnodesindex,] / sum(g[fnodesindex,])
    pij = pij[pij > 0]
    k = length(pij)
    Hiw = (-1 * sum(pij * log10(pij)))
    Diw = Hiw / log10(k)

    dgc$intra_clonotypic_entropy[dgc$pheno == f] = Hiw
    dgc$intra_clonotypic_diversity[dgc$pheno == f] = Diw

    sumpij =  sum(g[fnodesindex,])
    dgc$sumPij[dgc$pheno==f] = sumpij

    dgc$intra_cl[dgc$pheno == f] = sum(g[fnodesindex,]) * log10(sum(g[fnodesindex,]))


    ## joint distribution ####
    ## not needed- very few exact matches
    # dbj = db_gp %>% dplyr::group_by(ind, subset) %>%
    #   dplyr::summarise(n = n()) %>% tidyr::spread(key = subset, value = n, fill=0)
    #

    # each pij for nodes that are phenotype == f
    #pijg = db_gp[db_gp[[phenotype_var]] == f,]$pijg
    #-1 * sum(pijg * log10(pijg)


    #for (i in fnodesindex) {
    # sum(g[i,]) * log10(sum(g[fnodesindex,]))
    #}
    #db_gp$gll[i] = sum(g[i,]) * log10(sum(g[i,]))
  }


  return_list <- list("affinity_mat" = aff_mtx,
                      "db_clone" = db_gp,
                      #"g" = g,
                      "db_pheno"= dgc)

  return(return_list)
}

